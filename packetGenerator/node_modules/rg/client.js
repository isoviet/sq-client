'use strict';

let net = require('net');
let EventEmitter = require('events').EventEmitter;

let Future = require('./future');

let Packet = require('./packets/packet');
let Types = require('./format/types');
let Parser = require('./format');

let PRIVATE = Symbol('private');

function log(client, message)
{
	if (!client.isVerbose)
		return;

	console.log(message);
}

function sendBuffer(client, packet, buffer)
{
	let storage = client[PRIVATE];

	Packet.writeHeader(buffer, storage.packetId++, storage.deviceId);

	let future = Future.promisify(storage.socket.write, storage.socket)(buffer);
	return future
		.then(function()
		{
			log(client, `client sent a packet ${packet.name}(${packet.id})`);
		})
		.catch(function(error)
		{
			error.message = `sending error: ${error.message}`;
			throw error;
		});
}

function readChunk(client, chunk)
{
	try
	{
		let storage = client[PRIVATE];
		storage.buffer = Buffer.concat([storage.buffer, chunk]);

		while (storage.deficiency <= storage.buffer.length)
		{
			if (storage.deficiency === 0 && storage.buffer.length < Types.I.size())
				break;

			if (storage.deficiency === 0)
			{
				storage.deficiency = storage.buffer.readUInt32LE(0);
				storage.buffer = storage.buffer.slice(Types.I.size());
				continue;
			}

			let raw = storage.buffer.slice(0, storage.deficiency);
			storage.buffer = storage.buffer.slice(storage.deficiency);
			storage.deficiency = 0;

			let packet = Packet.search(raw, storage.packets.indexServer);

			if (!packet)
				return;

			let data = packet.read(raw);

			client.emit('packet', packet, data);
			client.emit(packet.id, packet, data);
		}
	}
	catch (error)
	{
		client.emit('error', error);
	}
}

class Client extends EventEmitter
{
	constructor(packets, settings, deviceId)
	{
		super();
		let storage = {};
		this[PRIVATE] = storage;

		storage.packets = packets;
		storage.host = settings.host || '127.0.0.1';
		storage.port = settings.port || 22227;
		storage.reconnect = settings.reconnect || false;
		storage.reconnectDuration = settings.reconnectDuration || 500;
		storage.verbose = settings.verbose || false;
		storage.packetId = 0;
		storage.deviceId = deviceId;
		Parser.formats.groupSize = settings.groupSize || 'I';
		Parser.formats.deviceSize = settings.deviceSize;

		storage.buffer = new Buffer(0);
		storage.deficiency = 0;

		storage.socket = new net.Socket();
		storage.socket.on('data', readChunk.bind(null, this));
		storage.socket.on('error', function(error){ this.emit('error', error, this); }.bind(this));

		storage.socket.on('connect', function()
		{
			storage.packetId = 0;
			storage.connected = true;
			log(this, `client connected on ${this.address}`);
			this.emit('connect', this);
		}.bind(this));

		storage.socket.on('close', function()
		{
			storage.connected = false;
			this.emit.bind(this, 'disconnect', this);

			if (!storage.reconnect)
				return;

			Future.delay(storage.reconnectDuration).then(this.connect.bind(this));
		}.bind(this));

		this.on('error', (error) =>
		{
			storage.connected = false;
			if (this.listeners('error').length <= 1)
				console.error(error);
		});
	}

	connect(withoutFuture)
	{
		withoutFuture = (withoutFuture === undefined ? false : withoutFuture);
		let storage = this[PRIVATE];

		storage.packetId = 0;

		if (withoutFuture)
		{
			storage.socket.connect(storage.port, storage.host);
			return;
		}

		let future = Future.promisify(storage.socket.connect, storage.socket)(storage.port, storage.host);

		return future
			.catch(function(error)
			{
				error.message = `connection error: ${error.message}`;
				this.emit('error', error, this);
				throw error;
			}.bind(this));
	}

	disconnect()
	{
		let storage = this[PRIVATE];
		let future = Future.promisify(storage.socket.end, storage.socket)();

		return future
			.then(function()
			{
				log(this, `client disconnected on ${this.address}`);
			}.bind(this))
			.catch(function(error)
			{
				error.message = `disconnection error: ${error.message}`;
				this.emit('error', error, this);
				throw error;
			}.bind(this));
	}

	send(packet, struct)
	{
		return sendBuffer(this, packet, packet.write(struct));
	}

	sendRandom(packet)
	{
		return sendBuffer(this, packet, packet.random);
	}

	sendRaw(packet, data)
	{
		return sendBuffer(this, packet, packet.write(data, Packet.RAW));
	}

	wait(event)
	{
		return new Future(function(resolve)
		{
			this.once(event, () => resolve(arguments));

		}.bind(this));
	}

	/**
	 * Adds the specified listener to receive events of the given type.
	 * @param {String, Packet} event
	 * <ul>
	 *   <li>'packet':<p/>
	 *   Emitted when the client received any packet.<p/>
	 *   client.on('packet', (packet, structuredData) => {});
	 *   </li>
	 *   <li>Packet:<p/>
	 *   Emitted when an client received current packet.<p/>
	 *   client.on(packets.client.LOGIN, (packet, structuredData) => {});
	 *   </li>
	 *   <li>'connect':<p/>
	 *   client.on('connect', (client) => {});
	 *   </li>
	 *   <li>'disconnect':<p/>
	 *   client.on('connect', (client) => {});
	 *   </li>
	 *   <li>'error':<p/>
	 *   client.on('error', (error, client) => {});
	 *   </li>
	 * </ul>
	 * @param {Function} callback a callback function
	 */
	on(event, callback)
	{
		super.on(event instanceof Packet ? event.id : event, callback);
	}

	/**
	 * Adds the specified listener to receive events of the given type.
	 * @param {String, Packet} event
	 * <ul>
	 *   <li>'packet':<p/>
	 *   Emitted when the client received any packet.<p/>
	 *   client.on('packet', (packet, structuredData) => {});
	 *   </li>
	 *   <li>Packet:<p/>
	 *   Emitted when an client received current packet.<p/>
	 *   client.on(packets.client.LOGIN, (packet, structuredData) => {});
	 *   </li>
	 *   <li>'connect':<p/>
	 *   client.on('connect', (client) => {});
	 *   </li>
	 *   <li>'disconnect':<p/>
	 *   client.on('connect', (client) => {});
	 *   </li>
	 *   <li>'error':<p/>
	 *   client.on('error', (error, client) => {});
	 *   </li>
	 * </ul>
	 * @param {Function} callback a callback function
	 */
	once(event, callback)
	{
		super.once(event instanceof Packet ? event.id : event, callback);
	}

	get isVerbose()
	{
		return this[PRIVATE].verbose;
	}

	get connected()
	{
		return this[PRIVATE].connected;
	}

	get address()
	{
		let storage = this[PRIVATE];
		return `${storage.host}:${storage.port}`;
	}
}
module.exports = Client;
