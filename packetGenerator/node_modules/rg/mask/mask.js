'use strict';

let format = require('../format');

let PRIVATE = Symbol('private');

function indexToId(index)
{
	return Math.pow(2, index);
}

function generatePacket(mask, necessary, flags)
{
	let struct = [necessary.struct];
	let signature = [necessary.signature];

	for (let i = 0, length = flags.length; i < Mask.SIZE && i < length; ++i)
	{
		let id = indexToId(i);

		if ((mask & id) === 0)
			continue;

		let currentStruct = flags[i].struct;

		if (currentStruct.length === 1 && currentStruct[0].name === undefined)
		{
			currentStruct = {
				name : flags[i].name,
				type : currentStruct[0].type,
				isGroup : currentStruct[0].isGroup
			};
		}

		struct.push(currentStruct);
		signature.push(flags[i].signature);
	}

	signature = signature.join('');
	struct = struct.concat.apply([], struct);

	struct = [{type : struct, isGroup : true}];
	signature = `[${signature}]`;

	console.log(signature)

	return {struct : struct, signature : signature};
}

function foldGroup(object, name, struct)
{
	if (struct.length === 1 && struct[0].name === undefined)
		return object[name];

	let result = {};

	struct.forEach((subStruct) =>
	{
		result[subStruct.name] = object[subStruct.name];
	});

	return result;
}

function foldObject(mask, necessary, flags, object)
{
	let result = foldGroup(object, null, necessary.struct);

	for (let i = 0, length = flags.length; i < Mask.SIZE && i < length; ++i)
	{
		let id = indexToId(i);

		if ((mask & id) === 0)
			continue;

		let flag = flags[i];

		result[flag.name] = foldGroup(object, flag.name, flag.struct);
	}

	return result;
}

function foldStruct(mask, necessary, flags, data)
{
	return data.map(foldObject.bind(null, mask, necessary, flags));
}

class Mask
{
	/**
	 * Creates a new Mask.
	 *
	 * @param {string} necessaryParams prefix format description: 'type:I, name:S'
	 * @param {array} mask mask elements : [{name: 'levels', description: 'user:I, leader:B'}, {}]
	 *
	 * @class
	 */
	constructor(necessaryParams, mask)
	{
		try
		{
			let storage = {};
			storage.necessary = format.cachePacket(necessaryParams);
			storage.mask = mask.map((flag) =>
			{
				let cache = format.cachePacket(flag.description);
				return {
					name: flag.name,
					struct: cache.struct,
					signature: cache.signature
				};
			});

			let flags = {};
			storage.mask.forEach((flag, index) =>
			{
				flags[flag.name] = indexToId(index);
			});

			this.flags = flags;

			this[PRIVATE] = storage;
		}
		catch(error)
		{
			error.message = `In mask generation: ${error.message}`;
			throw error;
		}
	}

	read(mask, data)
	{
		try
		{
			if (Array.isArray(mask))
				mask = mask.reduce((prev, current) => prev + current, 0);

			let storage = this[PRIVATE];
			let packet = generatePacket(mask, storage.necessary, storage.mask);

			let array = format.readMask(data, packet.signature, packet.struct);
			let struct = format.dataRawToStruct(array, packet.struct);
			let folded = foldStruct(mask, storage.necessary, storage.mask, struct[0]);
			return folded;
		}
		catch(error)
		{
			error.message = `In mask generation: ${error.message}`;
			throw error;
		}
	}

	get maskSize()
	{
		return Mask.SIZE;
	}

	get full()
	{
		return Mask.FULL;
	}
};

Mask.SIZE = 32;
Mask.FULL = 0xFFFFFFFF;

module.exports = Mask;