'use strict'

function keyName(key)
{
	return key.substr(2, key.length - 4);
}

function parseLine(line)
{
	let regexp = /\{\{[A-Z]+[A-Z0-9_]+\}\}/g;
	
	let result = [];

	while (true)
	{
		let prevIndex = regexp.lastIndex;
		let match = regexp.exec(line);

		if (!match)
		{
			let length = line.length - prevIndex;

			if (length > 0)
				result.push({isText : true, text : line.substr(prevIndex, line.length - prevIndex)});

			break;
		}

		let isFirst = match.index === 0;

		if (!isFirst)
			result.push({isText : true, text : line.substr(prevIndex, match.index - prevIndex)});

		result.push({isText : false, key : keyName(match[0]), isFirst});
	}

	return result;
}

function parse(fileData)
{
	let regexpTabs = /^([\t ]*)(.*)$/;

	fileData = fileData.replace(/\r/g, '');
	let lines = fileData.split('\n');
	let keys = {};

	lines = lines.map((line) =>
	{
		let match = regexpTabs.exec(line);
		let tabs = match[1];
		let data = match[2];

		let keysCount = 0;
		let textCount = 0;

		line = parseLine(data).map((token) =>
		{
			if (token.isText)
			{
				textCount++;
				return {text : token.text};
			}

			keysCount++;
			let key;
			
			if (!keys.hasOwnProperty(token.key))
				keys[token.key] = {name : token.key, text : undefined, canMultiLine : true, tabs : ''};
			
			key = keys[token.key];

			if (!token.isFirst)
				key.canMultiLine = false;

			return key;
		});

		let isSingleLine = (textCount > 0 || keysCount != 1);

		return {
			tabs,
			line,
			isSingleLine
		}
	});

	return {lines, keys};
}

function isMultiline(text)
{
	return /\n/.test(text);
}

class Templater
{
	constructor(name, fileData)
	{
		let data = parse(fileData);

		this.name = name;
		this.keys = data.keys;
		this.lines = data.lines;
	}

	set(key, value)
	{
		if (Array.isArray(value))
			value = value.join('\n');

		if (!this.keys.hasOwnProperty(key))
			throw new Error(`unexcepted setting key '${key}' in '${this.name}'`);

		let keyObject = this.keys[key];
		if (!keyObject.canMultiLine && isMultiline(value))
			throw new Error(`unexcepted multiline value in singleline key '${key}' in '${this.name}'`);

		keyObject.text = value;
	}

	clear()
	{
		for (let key in this.keys)
		{
			if (!this.keys.hasOwnProperty(key))
				continue;

			this.keys[key].text = undefined;
		}
	}

	stringify()
	{
		for (let key in this.keys)
		{
			if (!this.keys.hasOwnProperty(key))
				continue;

			if (this.keys[key].text !== undefined)
				continue;

			throw new Error(`not found value in key '${key}' in ${this.name}`);
		}

		let result = [];

		this.lines.forEach((line) =>
		{
			if (line.isSingleLine)
			{
				result.push(line.tabs + line.line.map((token) => token.text).join(''));
				return;

			}

			let keyObject = line.line[0];
			
			keyObject.text.split('\n').forEach((text) =>
			{
				result.push(line.tabs + text);
			});
		})

		return result.join('\n');
	}

	generate(keys)
	{
		this.clear();

		for (let key in keys)
		{
			if (!keys.hasOwnProperty(key))
				continue;

			this.set(key, keys[key]);
		}

		return this.stringify();
	}

	static removeEmptyLines(text)
	{
		return text.replace(/^\t+$/gm, '').replace(/\n\n\n+/g, '\n');
	}

	static removeSingleLineBrackets(text)
	{
		let parts = text.
			split(/(\t*!\{\n)|(\t*!\}\n)/g).
			filter(part => (part !== undefined)).
			map(part => {
				let bracketPart = part.trim();
				if (bracketPart === '!{')
					return {text : part.replace('!{', '{'), braket : 1, lines : 0};

				if (bracketPart === '!}')
					return {text : part.replace('!}', '}'), braket : -1, lines : 0};

				return {text : part, lines : Math.max(1, part.split('\n').length - 1)};
			});

		let brakets = [];
		parts.forEach((part) =>
		{
			switch (part.braket)
			{
				case 1:
					brakets.push(part);
					return;
				case -1:
					part.lines = brakets.pop().lines;
					return;
				default:
					brakets.forEach((braket) => braket.lines += part.lines);
					return;
			}
		});

		parts = parts.
			filter(part => (part.braket === undefined) || part.lines > 1).
			map(part => part.text)

		return parts.join('');
	}

}

module.exports = Templater;