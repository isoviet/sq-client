'use strict';

let format = require('../format');

let PRIVATE = Symbol('private');

class Packet
{
	constructor(id, name, fields, optional)
	{
		let storage = {};
		this[PRIVATE] = storage;

		storage.id = id;
		storage.name = name;

		let cache = format.cachePacket(fields, optional);
		storage.struct = cache.struct;
		storage.signature = cache.signature;
	}

	static writeHeader(buffer, id, deviceId)
	{
		format.writeHeader(buffer, id, deviceId);
	}

	static search(buffer, indexed)
	{
		let id = format.readHeader(buffer);

		let packet = indexed[id];

		if (!packet)
			return;

		return packet;
	}

	write(data, type)
	{
		try
		{
			let storage = this[PRIVATE];

			if (type === Packet.RAW)
				return format.writeBuffer(storage.id, data === undefined ? [] : data, storage.signature, storage.struct);

			let raw = format.dataStructToRaw(data || {}, storage.struct);
			return format.writeBuffer(storage.id, raw, storage.signature, storage.struct);
		}
		catch (error)
		{
			error.message = `In packet '${this.name}'(${this.id}) : ${error.message}`;
			throw error;
		}
	}

	read(buffer, type)
	{
		try
		{
			let storage = this[PRIVATE];

			let data = format.readBuffer(buffer, storage.signature, storage.struct);
			if (type === Packet.RAW)
				return data;

			return format.dataRawToStruct(data, storage.struct);
		}
		catch (error)
		{
			error.message = `In packet '${this.name}'(${this.id}) : ${error.message}`;
			throw error;
		}
	}

	get random()
	{
		let data;

		try
		{
			data = format.generateRandom(this[PRIVATE].signature);
		}
		catch (error)
		{
			error.message = `In packet '${this.name}' (${this.id}) : ${error.message}`;
			throw error;
		}

		return this.write(data, Packet.RAW);
	}

	get id()
	{
		return this[PRIVATE].id;
	}

	get name()
	{
		return this[PRIVATE].name;
	}
}

Packet.RAW = Symbol('raw');
Packet.STRUCT = Symbol('stuct');

module.exports = Packet;