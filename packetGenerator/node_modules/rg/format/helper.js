// Возможности работы со структурой:
// Сигнатура: BBI
// Описание: type:B, data:B, id:I
// Пакет: 	"BBI",				// NAME(ID); type:B, data:B, id:I
// Структура: [{name : "type", type : "B"}, {name : "data", type : "B"}, {name : "id", type : "I"}]
// Сырые данные: [10, 20, 30]
// Структурированные данные: {type : 10, data : 20, id : 30}
// Буффер: 0xFFABFBFBFB

'use strict';
let chance = new require('chance')(~~(Math.random() * 1000000000));
let Types = require('./types');

let fs = require('fs');
let Future = require('../future');

let formats =
{
	groupSize : 'I',
	deviceSize : null
};

function clientHeaderSize()
{
	let size = Types.I.size() * 2;

	if (formats.deviceSize)
		size += Types[formats.deviceSize].size();

	return size;
}

// вспомогательное
function randomGroupSize()
{
	const sizes = [3, 50, 100];
	let sizeType = chance.integer({min : 0, max : 3});

	if (sizes[sizeType] > 0)
		return chance.integer({min : 0, max : sizes[sizeType]});

	return 0;
}

function findClosingBracket(signature, index)
{
	let opened = 0;
	let closed = 0;

	for (let length = signature.length; index < length; index++)
	{
		switch (signature[index])
		{
			case '[':
				opened++;
				continue;
			case ']':
				if (opened === closed)
					return index;

				closed++;
				continue;
			default:
				break;
		}
	}

	throw new Error('bad brackets format');
}

// # Для парсинга отдельного пакета:
// 1. Проверка сигнатуры
// 2. Проверка описания
// 3. Сверка сигнатуры и описания
function parseSignature(signature)
{
	let result = [];
	let index = arguments[1] || {i : 0};

	for (let length = signature.length; index.i < length; index.i++)
	{
		let type = signature[index.i];
		switch (type)
		{
			case '[':
				index.i++;
				result.push(parseSignature(signature, index));
				continue;

			case ']':
				return result;

			default:
				result.push(type);
		}
	}

	return result;
}

function parseDescription(description, optimize)
{
	let index = arguments[2];
	if (!index)
	{
		let separator = /,|\[|\]|[a-zA-Z_]+:|[a-zA-Z_]+/g;
		description = description.match(separator) || [];
		description = description.map((field) => field.trim());
		description = description.filter((field) => field !== ',');
	
		index = index || {i : 0};
	}

	let result = [];
	let object = {name : undefined, type : undefined, isGroup : undefined};
	let is_name = /[a-zA-Z_]+:/;

	for (let length = description.length; index.i < length; index.i++)
	{
		let lexem = description[index.i];

		if (is_name.test(lexem))
		{
			object.name = lexem.replace(':', '');
			continue;
		}

		switch (lexem)
		{
			case '[':
				index.i++;
				object.type = parseDescription(description, optimize, index);

				if (optimize && object.type.length == 1)
					object.type = object.type[0];

				object.isGroup = true;
				result.push(object);
				object = {name : undefined, type : undefined, isGroup : undefined};
				continue;

			case ']':
				return result;

			default:
				if (!Types.hasOwnProperty(lexem))
					throw new Error(`invalid type ${lexem} in ${object.name ? object.name : 'unknown'}`);
				object.type = lexem;
				result.push(object);
				object = {name : undefined, type : undefined, isGroup : undefined};
		}
	}

	return result;
}

function compareSignatureDescription(signature, description)
{
	let isBranch = arguments[2];
	let signatureIndex = 0;
	let descriptionIndex = 0;
	let isOptional = false;

	let main = [];
	let optional = [];
	let current = main;

	let noname = (description.length == 1);

	for (let length = signature.length; signatureIndex < length; ++signatureIndex)
	{
		let type = signature[signatureIndex];

		if (type === ',')
		{
			if (isBranch)
				throw new Error('optional symbol "," in group');

			if (isOptional)
				throw new Error('duplicate optional symbol ","');

			current = optional;
			isOptional = true;
			continue;
		}

		let field = description[descriptionIndex];

		if (field.name === undefined && !noname)
			throw new Error(`unnamed field "${JSON.stringify(field.type)}"`);

		if (Array.isArray(type) !== Array.isArray(field.type))
			throw new Error(`different type for field "${field.name}"`);

		if (Array.isArray(type))
		{
			if (type.length !== field.type.length)
				throw new Error(`different length group for field "${field.name}" : ${type.length} !== ${field.type.length}`);

			current.push({name : field.name, type : compareSignatureDescription(type, field.type, true)});
		}
		else if (field.type !== type)
			throw new Error(`different type for field "${field.name}" : ${type} !== ${field.type}`);
		else if (!Types.hasOwnProperty(field.type))
			throw new Error(`invalid type ${field.type} in field "${field.name}"`);
		else
			current.push({name : field.name, type : field.type});

		descriptionIndex++;
	}

	if (isBranch)
		return main;

	return {main : main, optional : optional};
}


// # Десериализация
// 1. Получение описания из структуры
// 1. Получение сигнатуры из структуры
// 1. Получение размера из структуры
function structToDescription(struct)
{
	let isBranch = arguments[1];

	if (Array.isArray(struct))
	{
		let array = struct.map((value) => structToDescription(value, true)).join(', ');

		if (!isBranch)
			return array;

		return `[${array}]`;
	}

	if (typeof struct !== 'object')
		return struct;

	if (struct.name === undefined)
		return structToDescription(struct.type, true);

	return `${struct.name}:${structToDescription(struct.type, true)}`;
}

function structToSignature(struct)
{
	if (Array.isArray(struct))
	{
		let array = [];
		let hasOptional = false;

		for (let i = 0, length = struct.length; i < length; ++i)
		{
			if (!hasOptional && struct[i].optional)
			{
				hasOptional = true;
				array.push(',');
			}

			array.push(structToSignature(struct[i], true));
		}
		
		return array.join('');
	}

	if (typeof struct !== 'object')
		return struct;

	if (struct.isGroup)
		return `[${structToSignature(struct.type, true)}]`;

	return structToSignature(struct.type, true);
}

function structToDebugSignature(struct, debugIndex)
{
	let before = [];
	let after = [];

	if (Array.isArray(struct))
	{
		let array = debugIndex >= 0 ? before : after;
		let hasOptional = false;

		for (let i = 0, length = struct.length; i < length; ++i)
		{
			if (!hasOptional && struct[i].optional)
			{
				hasOptional = true;
				array.push(',');
			}

			let data = structToSignature(struct[i], true);
			
			if (i == debugIndex)
			{
				array = after;
				continue;
			}

			array.push(data);
		}

		return {
			before : before.join(''),
			after : after.join('')
		};
	}

	return struct;
}

function structToDebugDescription(struct, path, depth)
{
	let wrap = (data) => depth == path.length ? `**${data}**` : `${data}`;

	if (Array.isArray(struct))
	{
		let currentIndex = path[depth];
		let array = struct.map((value, index) =>
		{
			if (index != currentIndex)
				return structToDescription(value, true);

			return structToDebugDescription(value, path, depth + 1);
		}).join(', ');

		return `[${array}]`;
	}

	if (typeof struct !== 'object')
		return struct;

	if (struct.name === undefined)
		return wrap(structToDebugDescription(struct.type, path, depth));

	if (struct.isGroup && !Array.isArray(struct.type))
		return wrap(`${struct.name}:[${structToDebugDescription(struct.type, path, depth + 1)}]`);

	return wrap(`${struct.name}:${structToDebugDescription(struct.type, path, depth)}`);
}


// # Сериализация данных
// 1. Запись буффера из сырых данных
// 2. Чтение буффера в сырые данные
// 3. Генерация случайных сырых данных
function serialize(data, signature)
{
	let index = arguments[2] || {i : 0};

	let path = arguments[3] || [-1];
	let depth = arguments[4] || 0;

	let optional = false;
	let result = [];

	data = Array.isArray(data) ? data : [data];

	try
	{
		loop: for (let length = signature.length, dataLength = data.length, dataIndex = 0; index.i < length; ++index.i)
		{
			if (optional)
			{
				if (dataIndex >= dataLength)
					break;

				optional = false;
			}

			path[depth] = dataIndex;
			let symbol = signature[index.i];

			switch (symbol)
			{
				case ',':
					optional = true;

					continue;

				case '[':
				{
					let group = [];

					++index.i;
					let currentIndex = index.i;
					let currentData = data[dataIndex];
					path.push(-1);

					for (let j = 0, count = currentData.length; j < count; j++)
					{
						index.i = currentIndex;
						let groupData = serialize(currentData[j], signature, index, path, depth + 1);

						if (Array.isArray(groupData))
							group.push.apply(group, groupData);
						else
							group.push(groupData);
					}

					if (currentData.length === 0)
						index.i = findClosingBracket(signature, index.i);

					Types[formats.groupSize].writeTo(result, currentData.length);

					result.push.apply(result, group);

					dataIndex++;
					continue;
				}
				case ']':
					break loop;
			}

			Types[symbol].writeTo(result, data[dataIndex]);
			dataIndex++;
		}

		if (depth > 0 && result.length <= 1)
			return result[0];

		return result;
	}
	catch(error)
	{
		if (error instanceof Error)
			throw {error : error, path : path};

		throw error;
	}
}

function deserialize(buffer, signature, offset)
{
	let index = arguments[3] || {i : 0};

	let path = arguments[4] || [-1];
	let depth = arguments[5] || 0;

	let optional = false;
	let result = [];

	offset = (typeof offset === 'object' ? offset : {i : offset});

	try
	{
		loop: for (let length = signature.length, dataIndex = 0; index.i < length; ++index.i)
		{
			if (optional)
			{
				if (offset.i >= buffer.length)
					break;
			}

			path[depth] = dataIndex;

			let symbol = signature[index.i];

			switch (symbol)
			{
				case ',':
					optional = true;

					continue;

				case '[':
				{
					let count = Types[formats.groupSize].read(buffer, offset);

					let group = [];
					++index.i;
					let currentIndex = index.i;
					path.push(-1);

					for (let j = 0; j < count; j++)
					{
						index.i = currentIndex;
						group.push(deserialize(buffer, signature, offset, index, path, depth + 1));
					}

					if (count === 0)
						index.i = findClosingBracket(signature, index.i);

					result.push(group);

					dataIndex++;
					continue;
				}
				case ']':
					break loop;
			}

			Types[symbol].readTo(result, buffer, offset);
			dataIndex++;
		}

		if (depth > 0 && result.length <= 1)
			return result[0];

		return result;

	}
	catch(error)
	{
		if (error instanceof Error)
			throw {error : error, path : path};

		throw error;
	}
}

function writeRaw(buffer, objects, offset)
{
	objects.forEach((object) =>
	{
		Types[object.type].write(buffer, offset, object.value);

		offset += object.size;
	});
}

function writeBuffer(id, data, signature, struct)
{
	if (!Array.isArray(data))
		throw new Error(`data '${data}' is not array`);

	let mainLength = struct.reduce((sum, value) => sum + (!value.optional), 0);

	if (data.length != mainLength && data.length !== struct.length)
		throw new Error(`incorrect data size '${data.length}'`);

	let objects;

	try
	{
		objects = serialize(data, signature);
	}
	catch (debugError)
	{
		debugError.error.message = `${debugError.error.message} in '${debugPosition(struct, debugError.path)}'`;
		throw debugError.error;
	}

	//id
	objects.unshift(Types.W.writeTo([], id)[0]);

	let size = objects.reduce((prev, object) => prev + object.size, 0);

	let headerSize = clientHeaderSize();
	let buffer = new Buffer(size + headerSize);
	writeRaw(buffer, objects, headerSize);

	return buffer;
}

function writeHeader(buffer, id, deviceId)
{
	let header = [];
	Types.I.writeTo(header, buffer.length - Types.I.size());
	Types.I.writeTo(header, id);

	if (formats.deviceSize)
		Types[formats.deviceSize].writeTo(header, deviceId);

	writeRaw(buffer, header, 0);
}

function readBuffer(buffer, signature, struct)
{
	try
	{
		let offset = 2;
		return deserialize(buffer, signature, offset);
	}
	catch (debugError)
	{
		debugError.error.message = `${debugError.error.message} in '${debugPosition(struct, debugError.path)}'`;
		throw debugError.error;
	}
}

function readMask(buffer, signature, struct)
{
	try
	{
		let offset = 0;
		return deserialize(buffer, signature, offset);
	}
	catch (debugError)
	{
		debugError.error.message = `${debugError.error.message} in '${debugPosition(struct, debugError.path)}'`;
		throw debugError.error;
	}
}

function readHeader(buffer)
{
	return Types.W.read(buffer, {i : 0});
}

function generateRandom(signature)
{
	let index = arguments[1] || {i : 0};

	let isBranch = arguments[2];
	let hasOptional = !isBranch && chance.bool();
	let result = [];

	loop: for (let length = signature.length; index.i < length; ++index.i)
	{
		let symbol = signature[index.i];

		switch (symbol)
		{
			case ',':
				if (!hasOptional)
					break loop;

				continue;

			case '[':
			{
				let count = randomGroupSize();
				let group = [];

				++index.i;
				let currentIndex = index.i;

				for (let j = 0; j < count; j++)
				{
					index.i = currentIndex;
					group.push(generateRandom(signature, index, true));
				}

				if (count === 0)
					index.i = findClosingBracket(signature, index.i);

				result.push(group);
				continue;
			}
			case ']':
				break loop;
		}

		result.push(Types[symbol].random());
	}

	if (isBranch && result.length <= 1)
		return result[0];

	return result;
}


// # Сериализация структуры
// 1. Перевод структурированных данных в сырые
// 2. Перевод сырых данных в структурированные
function dataRawToStruct(data, struct)
{
	let isBranch = arguments[2];

	if (data === undefined)
		return;

	let noname = (!isBranch && struct.length === 1 && struct[0].name === undefined);

	if (noname)
	{
		struct = struct[0];
		data = data[0];

		if (data === undefined && !struct.optional)
			throw new Error(`invalid read noname field '${JSON.stringify(struct)}'`);

		return [dataRawToStruct(data, struct, true)];
	}

	if (struct.isGroup)
	{
		if (data !== undefined && !Array.isArray(data))
			throw new Error(`invalid read group '${JSON.stringify(struct)}'`);

		return data.map((value) => dataRawToStruct(value, struct.type, true));
	}

	if (!Array.isArray(struct))
		return data;

	let result = {};
	let hasOptional = false;

	struct.forEach((field, index) =>
	{
		if (index >= data.length)
		{
			if (!field.optional)
				throw new Error(`invalid read field '${field.name}:${JSON.stringify(field.type)}'`);

			return;
		}

		if (field.optional)
			hasOptional = true;

		result[field.name] = dataRawToStruct(data[index], field, true);
	});

	if (hasOptional)
		result.hasOptional = true;

	return result;
}

function dataStructToRaw(data, struct)
{
	let isBranch = arguments[2];

	let noname = (!isBranch && struct.length === 1 && struct[0].name === undefined);

 	if (noname)
 	{
 		struct = struct[0];
 		data = data[0];

 		if (data === undefined && !struct.optional)
 				throw new Error(`invalid write noname field '${JSON.stringify(struct)}'`);

 		return [dataStructToRaw(data, struct, true)];
 	}

 	if (typeof struct !== 'object')
 		return data;

 	if (struct.isGroup)
 	{
 		if (data !== undefined && !Array.isArray(data))
 			throw new Error(`invalid write group '${JSON.stringify(struct)}'`);

 		return data.map((value) => dataStructToRaw(value, struct.type, true));
 	}

 	if (!Array.isArray(struct))
 		return dataStructToRaw(data, struct.type, true);

 	let result = [];
 	let hasOptional = struct.some((field) => data.hasOwnProperty(field.name) && field.optional);

 	struct.forEach((field) =>
 	{
 		if (!data.hasOwnProperty(field.name))
 		{
 			if (!field.optional)
 			{
 				throw new Error(`invalid writed data: not found field '${field.name}'`);
 			}

 			if (hasOptional)
 				throw new Error(`invalid writed data: not found optional field '${field.name}'`);

 			return;
 		}

 		result.push(dataStructToRaw(data[field.name], field, true));
 	});

 	return result;
}


// # Отладка
// 1. Получение описания текущего места в пакете
function debugPosition(struct, path)
{
	if (path.length == 0)
		return structToSignature(struct);

	let index = path[0];
	let context = structToDebugSignature(struct, index);

	if (context.before !== undefined && context.before.length > 0)
		context.before = context.before + ' ';
	else
		context.before = '';

	if (context.after !== undefined && context.after.length > 0)
		context.after = ' ' + context.after;
	else
		context.after = '';

	let debug = structToDebugDescription(struct[index], path, 1);

	if (debug === undefined)
		debug = '';

	return `${context.before}<${debug}>${context.after}`;
}


// # Подготовка пакета
// 1. Генерация класса пакета
// 2. Кеширование данных из класса пакета
function preparePacketStruct(id, name, signatureString, descriptionString)
{
	try
	{
		let signature = parseSignature(signatureString);
		let description = parseDescription(descriptionString);
		let data = compareSignatureDescription(signature, description);
		let main = structToDescription(data.main);
		let optional = structToDescription(data.optional);

		return {id, name, signature, description, data, main, optional};
	}
	catch (error)
	{
		error.message = `in packet ${name} : ${error.message}`;
		throw error;
	}
}

function preparePacket(id, name, signatureString, descriptionString)
{
	try
	{
		let packet = preparePacketStruct(id, name, signatureString, descriptionString);

		let options = [id, `'${name}'`];

		if (packet.main.length > 0 || packet.optional.length > 0)
			options.push(`'${packet.main}'`);

		if (packet.optional.length > 0)
			options.push(`'${packet.optional}'`);

		return `${name} : new Packet(${options.join(', ')})`;
	}
	catch (error)
	{
		error.message = `in packet ${name} : ${error.message}`;
		throw error;
	}
}

function cachePacket(description, descriptionOptional)
{
	description = description || '';
	descriptionOptional = descriptionOptional || '';

	let parsed = parseDescription(description, true);
	let parsedOptional = parseDescription(descriptionOptional, true);

	let raw = structToSignature(parsed);
	let rawOptional = structToSignature(parsedOptional);

	parsedOptional.forEach((field) => {field.optional = true});

	let struct = parsed.concat(parsedOptional);
	let signature = raw + (rawOptional.length > 0 ? ',' : '') + rawOptional;

	return {
		struct : struct,
		signature : signature
	};
}

function parsePacket(line, isStruct)
{
	line = line.trim();

	const separator = /"|\/\/ |\(|\);/;
	var args = line.split(separator);

	if (args.length !== 6)
		return;

	var signature = (args[1] || '').trim();
	var name = (args[3] || '').trim();
	var id = parseInt(args[4]);
	var description = (args[5] || '').trim();

	if (isStruct)
		return preparePacketStruct(id, name, signature, description);

	return preparePacket(id, name, signature, description);
}

function parsePacketsSync(data, isStruct)
{
	let lines =
		data.split('\n')
		.map((line) => line.trim())
		.filter((line) => line[0] === '"');

	let length = lines.length;
	let result = [];

	let ids = {};

	for (let i = 0; i < length; i++)
	{
		let packet = parsePacket(lines[i], isStruct);

		if (packet === undefined)
			throw new Error(`invalid packet '${lines[i]}'`);

		if (ids.hasOwnProperty(packet.id))
			throw new Error(`duplicate packet id '${packet.id}' with names '${packet.name}' and '${ids[packet.id].name}'`);

		ids[packet.id] = packet;

		result.push(packet);
	}

	return result;
}

function parsePackets(data, resolve, reject)
{
	try
	{
		resolve(parsePacketsSync(data, false));
	}
	catch (error)
	{
		reject(error);
	}
}

function parseFile(path)
{
	return fs.readFileAsync(path, {encoding : 'utf8'}).then((data) => new Future(parsePackets.bind(null, data)));
}

module.exports =
{
	preparePacket : preparePacket,

	writeBuffer : writeBuffer,
	writeHeader : writeHeader,
	readBuffer : readBuffer,
	readMask : readMask,
	readHeader : readHeader,
	generateRandom : generateRandom,
	dataRawToStruct : dataRawToStruct,
	dataStructToRaw : dataStructToRaw,
	debugPosition : debugPosition,
	cachePacket : cachePacket,
	formats : formats,

	parsePacket : parsePacket,
	parsePackets : parsePackets,
	parseFile : parseFile,
	parsePacketsSync : parsePacketsSync
};