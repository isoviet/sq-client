'use strict';

let chance = new require('chance')(~~(Math.random() * 1000000000));
let Long = new require('long');

function isNumber(n)
{
	return !Array.isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);
}

function randomInteger(smallMax, bigMax)
{
	let max = chance.bool() ? smallMax : bigMax;
	return chance.natural({min : 0, max : max});
}

function writeIntegerTo(type, array, value)
{
	if (!isNumber(value))
		throw new Error(`incorrect number '${JSON.stringify(value)}'`);

	value = Math.trunc(value);

	if (value < 0 || value > types[type].max)
		throw new Error(`incorrect ${type} number '${JSON.stringify(value)}'`);

	array.push({type : type, size : types[type].size(), value});
	return array;
}

function readNumber(type, reader, buffer, offset)
{
	let size = types[type].size();

	if (buffer.length < offset.i + size)
		throw new Error(`unexpected packet ending (can't read ${size} bytes)`);

	let data = reader.call(buffer, offset.i);
	offset.i = offset.i + size;

	return data;
}

function readTo(type, array, buffer, offset)
{
	array.push(types[type].read(buffer, offset));
}

let types =
{
	"B" :
	{
		writeTo : writeIntegerTo.bind(null, 'B'),
		write : (buffer, offset, value) => buffer.writeUInt8(value, offset),
		readTo : readTo.bind(null, 'B'),
		read : readNumber.bind(null, 'B', Buffer.prototype.readUInt8),
		random : randomInteger.bind(null, 10, 0xFF),
		size : () => 1,
		max : 0xFF
	},

	"W" :
	{
		writeTo : writeIntegerTo.bind(null, 'W'),
		write : (buffer, offset, value) => buffer.writeUInt16LE(value, offset),
		readTo : readTo.bind(null, 'W'),
		read : readNumber.bind(null, 'W', Buffer.prototype.readUInt16LE),
		random : randomInteger.bind(null, 10, 0xFFFF),
		size : () => 2,
		max : 0xFFFF
	},

	"I" :
	{
		writeTo : writeIntegerTo.bind(null, 'I'),
		write : (buffer, offset, value) => buffer.writeUInt32LE(value, offset),
		readTo : readTo.bind(null, 'I'),
		read : readNumber.bind(null, 'I', Buffer.prototype.readUInt32LE),
		random : randomInteger.bind(null, 10, 0xFFFF),
		size : () => 4,
		max : 0xFFFFFFFF
	},

	"L" :
	{

		writeTo : (array, value) =>
		{
			if (!(value instanceof Long))
			{
				if (typeof value === 'string')
					value = Long.fromString(value);
				else if (isNumber(value))
					value = Long.fromNumber(value);
				else
					throw new Error(`incorrect long '${JSON.stringify(value)}'`);
			}

			types.I.writeTo(array, value.getLowBitsUnsigned());
			types.I.writeTo(array, value.getHighBitsUnsigned());

			return array;
		},

		readTo : readTo.bind(null, 'L'),
		read : (buffer, offset) =>
		{
			let low = types.I.read(buffer, offset);
			let high = types.I.read(buffer, offset);

			return new Long(low, high);
		},

		random : () =>
		{
			let low = chance.natural({min : 0, max : 0xFFFFFFFF});
			let high = chance.natural({min : 0, max : 0xFFFFFFFF});

			return new Long(low, high);
		},

		size : () => 8
	},

	"N" :
	{

		writeTo : (array, value) =>
		{
			types.L.writeTo(array, value.high);
			types.L.writeTo(array, value.low);

			return array;
		},

		readTo : readTo.bind(null, 'N'),
		read : (buffer, offset) =>
		{
			let high = types.L.read(buffer, offset);
			let low = types.L.read(buffer, offset);

			return {low, high};
		},

		random : () =>
		{
			let low = types.L.random();
			let high = types.L.random();

			return {low, high};
		},

		size : () => 16
	},

	"S" :
	{
		writeTo : (array, value) =>
		{
			value = `${value}`;

			let length = Buffer.byteLength(value, 'utf8');
			types.W.writeTo(array, length);
			array.push({type : 'S', size : length, value});
			types.B.writeTo(array, 0); // null end

			return array;
		},

		write : (buffer, offset, value) => buffer.write(value, offset, Buffer.byteLength(value, 'utf8'), 'utf8'),

		readTo : readTo.bind(null, 'S'),
		read : (buffer, offset) =>
		{
			let size = types.W.read(buffer, offset);

			if (buffer.length < offset.i + size)
				throw new Error(`unexpected packet ending (can't read ${size} bytes)`);

			let data = buffer.toString('utf8', offset.i, offset.i + size);
			offset.i += size;

			types.B.read(buffer, offset); // null end 

			return data;
		},


		random : () =>
		{
			if (chance.bool())
				return chance.word();

			return chance.sentence();
		},
		size : (data) => `${value}`.length
	},

	"A" :
	{
		writeTo : (array, value) =>
		{
			value = (value instanceof Buffer ? value : new Buffer(`${value}`));

			types.I.writeTo(array, value.length);
			array.push({type : 'A', size : value.length, value});
			return array;
		},

		write : (buffer, offset, value) => value.copy(buffer, offset),

		readTo : readTo.bind(null, 'A'),
		read : (buffer, offset) =>
		{
			let size = types.I.read(buffer, offset);

			if (buffer.length < offset.i + size)
				throw new Error(`unexpected packet ending (can't read ${size} bytes)`);

			let data = new Buffer(size);
			buffer.copy(data, 0, offset.i);
			offset.i += size;

			return data;
		},

		random : () => chance.bool() ? new Buffer(types.S.random()) : new Buffer([]),
		size : (data) => (value instanceof Buffer ? value.length : `${value}`.length)
	},

	"F" :
	{
		writeTo : (array, value) =>
		{
			if (!isNumber(value))
				throw new Error(`incorrect number '${JSON.stringify(value)}'`);

			value = parseFloat(value);

			array.push({type : 'F', size : types.F.size(), value});
			return array;
		},

		write : (buffer, offset, value) => buffer.writeFloatLE(value, offset),

		readTo : readTo.bind(null, 'F'),
		read : readNumber.bind(null, 'F', Buffer.prototype.readFloatLE),

		random : () =>
		{
			if (chance.bool())
				return chance.floating({min: -1, max: 1});

			return chance.floating();
		},
		size : () => 4
	}
};

module.exports = types;