'use strict';

let helper = require('./helper');
let Templater = require('../templater');

function toCamelCase(name)
{
	return name.split('_').map(
		(part) => part.substr(0, 1).toUpperCase() + part.substr(1, part.length).toLowerCase()
	).join('');
}

function fieldName(name)
{
	name = name || 'items';
	return name.split('_').map(
		(part, index) => index === 0 ? part.toLowerCase() : (part.substr(0, 1).toUpperCase() + part.substr(1, part.length).toLowerCase())
	).join('');
}

function concatFieldName(prefix, name)
{
	return prefix + name.substr(0, 1).toUpperCase() + name.substr(1, name.length);
}

function isSimpleType(type)
{
	return typeof type === 'string';
}

function isSimpleArray(type)
{
	if (!Array.isArray(type))
		return false;

	if (type.length !== 1)
		return false;

	if (type[0].name !== undefined)
		return false;

	let subType = type[0].type;
	return isSimpleType(subType) || isSimpleArray(subType);
}

function isStructType(type)
{
	return !isSimpleType(type.type) && !isSimpleArray(type.type);
}

function getMetaType(field, metaTypes)
{
	for (let key in metaTypes)
	{
		if (!metaTypes.hasOwnProperty(key))
			continue;

		let metaType = metaTypes[key];

		if (metaType.parentType !== field.type)
			continue;

		if (!metaType.regexp.test(field.name))
			continue;

		return key;
	}
}

class AS3PacketGenerator
{
	constructor(settings)
	{
		this.settings = settings;
		this.structs = [];
		this.packets = [];
		this.list = [];

		this.initWriters();
		this.initReaders();

		this.packetTemplate = new Templater('packetTemplate', settings.code.packet);
		this.packetNameTemplate = new Templater('packetNameTemplate', settings.templates.packetName);
		this.packetFileTemplate = new Templater('packetFileTemplate', settings.templates.packetFile);

		this.structTemplate = new Templater('structTemplate', settings.code.struct);
		this.structFileTemplate = new Templater('structFileTemplate', settings.templates.structFile);

		this.parsingSimpleTemplate = new Templater('parsingSimpleTemplate', settings.codeParsing.simple);
		this.parsingStructTemplate = new Templater('parsingStructTemplate', settings.codeParsing.struct);
		this.parsingLoopTemplate = new Templater('parsingLoopTemplate', settings.codeParsing.loop);
		this.parsingOptionalTemplate = new Templater('parsingOptionalTemplate', settings.codeParsing.optional);

		this.buildingSimpleTemplate = new Templater('buildingSimpleTemplate', settings.codeBuilding.simple);
		this.buildingStructTemplate = new Templater('buildingStructTemplate', settings.codeBuilding.struct);
		this.buildingLoopTemplate = new Templater('buildingLoopTemplate', settings.codeBuilding.loop);
		this.buildingOptionalTemplate = new Templater('buildingOptionalTemplate', settings.codeBuilding.optional);

		this.readingSimpleTemplate = new Templater('readingSimpleTemplate', settings.codeReading.simple);
		this.readingStructTemplate = new Templater('readingStructTemplate', settings.codeReading.struct);
		this.readingLoopTemplate = new Templater('readingLoopTemplate', settings.codeReading.loop);
		this.readingOptionalTemplate = new Templater('readingOptionalTemplate', settings.codeReading.optional);

		this.loopCountTemplate = new Templater('LoopCountTemplate', settings.code.loopCount);
		this.helperVariableTemplate = new Templater('HelperVariable', settings.code.helperVariable);

		this.initializationTemplate = new Templater('initializationTemplate', settings.code.initialization);
		this.arrayTemplate = new Templater('arrayTemplate', settings.types.array.type);

		this.managerTemplate = new Templater('managerTemplate', settings.manager.manager);
		this.managerPacketTemplate = new Templater('managerPacketTemplate', settings.manager.packet);
		this.managerEmptyPacketTemplate = new Templater('managerEmptyPacketTemplate', settings.manager.emptyPacket);

		this.generate(settings.packetsPath);
	}

	getCounter(deep)
	{
		let count = this.settings.counters.length;

		if (deep < count)
			return `${this.settings.counters[deep]}`;

		return `${this.settings.counters[count - 1]}${deep}`;
	}

	packetToString(packet)
	{
		return this.packetTemplate.generate({
			'PACKET_ID'		: packet.id,
			'PACKET_NAME'	: packet.name,
			'VARIABLES'		: packet.variables,
			'PARSING'		: packet.parsing,
			'BUILDING'		: packet.building,
			'READING'		: packet.reading
		});
	}

	structToString(struct)
	{
		return this.structTemplate.generate({
			'STRUCT_NAME'	: struct.name,
			'VARIABLES'		: struct.variables,
			'PARSING'		: struct.parsing,
			'BUILDING'		: struct.building,
			'READING'		: struct.reading
		});
	}

	toArrayType(type, rawType)
	{
		return {
			type : this.settings.types.array.type,
			isObject : this.settings.types.array.isObject,
			default : this.settings.types.array.default,
			isArray : true,
			data : {
				name : "arrayItem",
				stringType : this.fieldTypeToString(type),
				rawType : type.rawType,
				type : type
			}
		};
	}

	fieldTypeToString(preparedType)
	{
		if (!preparedType.isArray)
			return preparedType.type;

		return this.arrayTemplate.generate({
			'ITEM' : this.fieldTypeToString(preparedType.data.type)
		});
	}

	initWriters()
	{
		for (var key in this.settings.builders)
		{
			if (!this.settings.builders.hasOwnProperty(key))
				continue;

			this.settings.builders[key] = new Templater(`builder${key}`, this.settings.builders[key]);
		}
	}

	initReaders()
	{
		for (var key in this.settings.readers)
		{
			if (!this.settings.readers.hasOwnProperty(key))
				continue;

			this.settings.readers[key] = new Templater(`reader${key}`, this.settings.readers[key]);
		}
	}

	getSimpleParser(type)
	{
		if (!this.settings.parsers.hasOwnProperty(type))
			return 'UNDEFINED';

		return this.settings.parsers[type];
	}

	getSimpleWriter(type)
	{
		if (!this.settings.builders.hasOwnProperty(type))
			return 'UNDEFINED';

		return this.settings.builders[type];
	}

	getSimpleReader(type)
	{
		if (!this.settings.readers.hasOwnProperty(type))
			return 'UNDEFINED';

		return this.settings.readers[type];
	}

	prepareFieldType(parentName, name, field)
	{
		if (isSimpleType(field.type))
		{
			let type = getMetaType(field, this.settings.metaTypes);

			if (!type)
				return this.settings.types[field.type];

			return this.settings.types[type];
		}

		if (isSimpleArray(field.type))
		{
			let innerType = this.prepareFieldType(parentName, name, field.type[0]);
			return this.toArrayType(innerType);
		}

		return this.toArrayType({type : concatFieldName(parentName, name), isObject : true, isStruct : true});
	}

	prepareField(parentName, field)
	{
		let name = fieldName(field.name);
		let type = this.prepareFieldType(parentName, name, field);

		let rawType = undefined;

		if (isSimpleType(field.type))
		{
			let metaType = getMetaType(field, this.settings.metaTypes);
			rawType = metaType ? this.settings.types[metaType].rawType : field.type;
		}

		let stringType = this.fieldTypeToString(type);

		if (isStructType(field))
			this.addStruct(parentName, field);
		
		return {name, type, rawType, stringType};
	}

	prepareFields(parentName, fields)
	{
		return fields.map(function(field)
		{
			return this.prepareField(parentName, field);
		}.bind(this));
	}

	addHelperVariables(parsing, helperVariables)
	{
		let variables = [];

		for (let item of helperVariables)
			variables.push(this.helperVariableTemplate.generate({'NAME' : item}));

		if (variables.length === 0)
			return parsing;

		return variables.concat([''], parsing);
	}

	generateOptionalParsing(helperVariables, parsing, preparedFields)
	{
		parsing.push('\n// optional');
		preparedFields.forEach(function(preparedField)
		{
			let initialization = this.addParsing(helperVariables, preparedField, true);

			parsing.push(this.parsingOptionalTemplate.generate({
				'INIT' : initialization
			}));
		}.bind(this));
	}

	generateOptionalBuilding(building, field)
	{
		if (field.type.default !== 'null')
			return;

		building.push(this.buildingOptionalTemplate.generate({
			'NAME' : field.name
		}));
	}

	generateOptionalReading(reading, index)
	{
		reading.push(this.readingOptionalTemplate.generate({
			'INDEX' : `${index}`
		}));
	}

	generateParsingCode(variables, helperVariables, parsing, preparedFields, isOptional)
	{
		if (preparedFields.length > 0 && isOptional)
		{
			variables.push('\n// optional');
			this.generateOptionalParsing(helperVariables, parsing, preparedFields);
		}

		preparedFields.forEach(function(field)
		{
			variables.push(this.addInitialization(field));

			if (isOptional)
				return;

			parsing.push(this.addParsing(helperVariables, field, isOptional));
		}.bind(this));
	}

	generateBuildingCode(helperVariables, building, preparedFields, isOptional)
	{
		if (preparedFields.length > 0 && isOptional)
			building.push('\n// optional');

		preparedFields.forEach(function(field)
		{
			if (isOptional)
				this.generateOptionalBuilding(building, field);

			building.push(this.addBuilding(helperVariables, field, isOptional));
		}.bind(this));
	}

	generateReadingCode(helperVariables, reading, preparedFields, isOptional, offset)
	{
		if (preparedFields.length > 0 && isOptional)
			reading.push('\n// optional');

		preparedFields.forEach(function(field, index)
		{
			if (isOptional)
				this.generateOptionalReading(reading, index + offset);

			reading.push(this.addReading(helperVariables, field, isOptional, 0, index + offset));
		}.bind(this));
	}

	addInitialization(preparedField)
	{
		return this.initializationTemplate.generate({
			'NAME'		: preparedField.name,
			'TYPE'		: preparedField.stringType,
			'DEFAULT'	: preparedField.type.default || 'null'
		});
	}

	addParsing(helperVariables, preparedField, isOptional, deep)
	{
		deep = (deep === undefined) ? 0 : deep;

		let type = preparedField.type;
		if (type.isArray)
		{
			let counterVariable = this.getCounter(deep);
			let countVariable = fieldName(this.loopCountTemplate.generate({"COUNTER" : counterVariable}));

			helperVariables.add(counterVariable);
			helperVariables.add(countVariable);

			type.data.name = `${preparedField.name}[${counterVariable}]`;
			return this.parsingLoopTemplate.generate({
				"NAME" : preparedField.name,
				"TYPE" : preparedField.stringType,
				"COUNTER" : counterVariable,
				"COUNT_VARIABLE" : countVariable,
				"COUNT" : this.getSimpleParser('GroupSize'),
				"BODY" : this.addParsing(helperVariables, type.data, false, deep + 1)
			});
		}

		if (type.isObject)
		{
			return this.parsingStructTemplate.generate({
				"NAME" : preparedField.name,
				"TYPE" : type.type
			});
		}

		return this.parsingSimpleTemplate.generate({
			"NAME" : preparedField.name,
			"PARSING" : this.getSimpleParser(preparedField.rawType)
		});
	}

	addBuilding(helperVariables, preparedField, isOptional, deep)
	{
		deep = (deep === undefined) ? 0 : deep;

		let type = preparedField.type;
		if (type.isArray)
		{
			let counterVariable = this.getCounter(deep);
			let countVariable = fieldName(this.loopCountTemplate.generate({"COUNTER" : counterVariable}));

			helperVariables.add(counterVariable);
			helperVariables.add(countVariable);

			type.data.name = `${preparedField.name}[${counterVariable}]`;
			return this.buildingLoopTemplate.generate({
				"NAME" : preparedField.name,
				"COUNTER" : counterVariable,
				"COUNT_VARIABLE" : countVariable,
				"WRITE_COUNT" : this.getSimpleWriter('GroupSize').generate({"NAME" : countVariable}),
				"BODY" : this.addBuilding(helperVariables, type.data, false, deep + 1)
			});
		}

		if (type.isObject)
		{
			return this.buildingStructTemplate.generate({
				"NAME" : preparedField.name
			});
		}

		return this.buildingSimpleTemplate.generate({
			"BUILDING" : this.getSimpleWriter(preparedField.rawType).generate({"NAME" : preparedField.name})
		});
	}

	addReading(helperVariables, preparedField, isOptional, deep, index)
	{
		deep = (deep === undefined) ? 0 : deep;
		index = (index === undefined) ? 0 : index;

		let type = preparedField.type;
		if (type.isArray)
		{
			let counterVariable = this.getCounter(deep);
			let countVariable = fieldName(this.loopCountTemplate.generate({"COUNTER" : counterVariable}));
			let arrayVariable = preparedField.array ? `${preparedField.array}[${index}]` : `array[${index}]`;

			helperVariables.add(counterVariable);
			helperVariables.add(countVariable);

			type.data.name = `${preparedField.name}[${counterVariable}]`;
			type.data.array = arrayVariable;

			return this.readingLoopTemplate.generate({
				"NAME" : preparedField.name,
				"TYPE" : preparedField.stringType,
				"COUNTER" : counterVariable,
				"ARRAY_VARIABLE" : arrayVariable,
				"COUNT_VARIABLE" : countVariable,
				"BODY" : this.addReading(helperVariables, type.data, false, deep + 1, counterVariable)
			});
		}

		if (type.isObject)
		{
			return this.readingStructTemplate.generate({
				"NAME" : preparedField.name,
				"TYPE" : type.type,
				"ARRAY" : preparedField.array || 'array'
			});
		}

		let reader = this.getSimpleReader(type.rawType).generate({'VALUE' : 'SPLITTER'}).split('SPLITTER');

		return this.readingSimpleTemplate.generate({
			"NAME" : preparedField.name,
			"INDEX" : index,
			"ARRAY" : preparedField.array || 'array',
			"CONVERTER_BEGIN" : reader[0],
			"CONVERTER_END" : reader[1]
		});
	}

	addStruct(parentName, struct)
	{
		let name = concatFieldName(parentName, fieldName(struct.name));

		let variables = [];

		let parsingHelperVariables = new Set();
		let parsing = [];

		let buildingHelperVariables = new Set();
		let building = [];

		let readingHelperVariables = new Set();
		let reading = [];

		let prepared = this.prepareFields(name, struct.type);
		this.generateParsingCode(variables, parsingHelperVariables, parsing, prepared);
		parsing = this.addHelperVariables(parsing, parsingHelperVariables);

		this.generateBuildingCode(buildingHelperVariables, building, prepared);
		building = this.addHelperVariables(building, buildingHelperVariables);

		this.generateReadingCode(readingHelperVariables, reading, prepared, false, 0);
		reading = this.addHelperVariables(reading, readingHelperVariables);

		this.structs.push({
			name,
			variables,
			parsing,
			building,
			reading
		});
	}

	generatePacket(packet)
	{
		let rawName = toCamelCase(packet.name);
		let name = this.packetNameTemplate.generate({"NAME" : rawName});

		let variables = [];

		let parsingHelperVariables = new Set();
		let parsing = [];

		let buildingHelperVariables = new Set();
		let building = [];

		let readingHelperVariables = new Set();
		let reading = [];

		let prepared = this.prepareFields(name, packet.data.main);
		let preparedOptional = this.prepareFields(name, packet.data.optional);

		this.generateParsingCode(variables, parsingHelperVariables, parsing, prepared, false);
		this.generateParsingCode(variables, parsingHelperVariables, parsing, preparedOptional, true);
		parsing = this.addHelperVariables(parsing, parsingHelperVariables);

		this.generateBuildingCode(buildingHelperVariables, building, prepared, false);
		this.generateBuildingCode(buildingHelperVariables, building, preparedOptional, true);
		building = this.addHelperVariables(building, buildingHelperVariables);

		this.generateReadingCode(readingHelperVariables, reading, prepared, false, 0);
		this.generateReadingCode(readingHelperVariables, reading, preparedOptional, true, prepared.length);
		reading = this.addHelperVariables(reading, readingHelperVariables);

		this.packets.push({
			id : packet.id,
			rawName,
			name,
			variables,
			parsing,
			building,
			reading
		});
	}

	generateList()
	{
		let count = this.packets.length;
		this.list = this.packets.map(function(packet, index)
		{
			let template = (packet.variables.length === 0) ? this.managerEmptyPacketTemplate : this.managerPacketTemplate;
			let separator = (index === count - 1 ? '' : ',');
			return template.generate({"NAME" : packet.name, "ID" : packet.id, "SEPARATOR" : separator});
		}.bind(this));
	}

	generate(serverPackets)
	{
		let packets = helper.parsePacketsSync(serverPackets, true);

		packets.forEach(this.generatePacket.bind(this));
		this.generateList();
	}

	write(folder)
	{
		let fs = require('fs-extra');
		let path = require('path');

		fs.removeSync(folder);

		this.packets.forEach(function(packet)
		{
			let name = this.packetFileTemplate.generate({"NAME" : packet.rawName});
			let filePath = path.join(folder, name);
			fs.createFileSync(filePath);
			fs.writeFileSync(filePath, Templater.removeEmptyLines(Templater.removeSingleLineBrackets(this.packetToString(packet))), {encoding : 'utf8'});
		}.bind(this));

		this.structs.forEach(function(struct)
		{
			let name = this.structFileTemplate.generate({"NAME" : struct.name});
			let filePath = path.join(folder, name);
			fs.createFileSync(filePath);
			fs.writeFileSync(filePath, Templater.removeEmptyLines(Templater.removeSingleLineBrackets(this.structToString(struct))), {encoding : 'utf8'});
		}.bind(this));

		let list = this.managerTemplate.generate({"LIST" : this.list});

		let filePath = path.join(folder, this.settings.templates.managerFile);
		fs.createFileSync(filePath);
		fs.writeFileSync(filePath, Templater.removeEmptyLines(list), {encoding : 'utf8'});

		let abstractFilePath = path.join(folder, this.settings.abstract.name);
		fs.createFileSync(abstractFilePath);
		fs.writeFileSync(abstractFilePath, this.settings.abstract.file, {encoding : 'utf8'});
	}
}

function generatePackets(settings)
{
	(new AS3PacketGenerator(settings)).write(settings.outputPath);
}

module.exports =
{
	generatePackets : generatePackets
};